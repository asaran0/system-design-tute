Perfect. Letâ€™s go **FAANG-level deep** on **Pattern #1: Sliding Window** â€” the way Google/Amazon expect you to *recognize, think, and implement* it in interviews.

Iâ€™ll structure this exactly for **systematic mastery** ğŸ‘‡

---

# ğŸ”¥ PATTERN #1: SLIDING WINDOW (FULL DEPTH)

## 1ï¸âƒ£ What is Sliding Window (Core Idea)

Sliding Window is an **optimization pattern** used to reduce **O(nÂ²)** brute-force solutions to **O(n)** by:

> Maintaining a *window (subarray / substring)* and moving it **step-by-step** instead of recomputing everything again.

### When brute force looks like:

```text
for each start:
    for each end:
        process subarray(start, end)
```

Sliding Window converts it to:

```text
move right pointer â†’
adjust window
if invalid â†’ move left pointer â†’
```

---

## 2ï¸âƒ£ Absolute Recognition Rule (VERY IMPORTANT)

ğŸ‘‰ **Ask yourself this FIRST in interview:**

> â€œIs the problem asking about a **contiguous subarray or substring**?â€

If **YES** â†’ Sliding Window is a **top candidate**.

---

## 3ï¸âƒ£ Types of Sliding Window (CRITICAL CLASSIFICATION)

### ğŸ”¹ TYPE 1: Fixed-Size Window

Window size is **constant (k)**

ğŸ“Œ Keywords:

* â€œsubarray of size kâ€
* â€œwindow of length kâ€
* â€œk consecutive elementsâ€

Examples:

* Max sum subarray of size k
* Averages of subarrays of size k

---

### ğŸ”¹ TYPE 2: Variable-Size Window (MOST IMPORTANT)

Window expands & shrinks dynamically based on a condition.

ğŸ“Œ Keywords:

* â€œlongestâ€
* â€œsmallestâ€
* â€œat most / at leastâ€
* â€œwithout repeatingâ€
* â€œsum â‰¥ kâ€
* â€œsubstring with conditionâ€

---

### ğŸ”¹ TYPE 3: Sliding Window + HashMap

Used when **frequency / uniqueness / distinct elements** matter.

ğŸ“Œ Keywords:

* â€œdistinctâ€
* â€œuniqueâ€
* â€œno repeating charactersâ€
* â€œanagramâ€
* â€œfrequencyâ€

---

## 4ï¸âƒ£ Master Mental Model (INTERVIEW GOLD)

### ğŸ¯ Two Pointers

* `left` â†’ shrinks window
* `right` â†’ expands window

### ğŸ¯ Window State

* sum
* count
* frequency map
* max/min value

### ğŸ¯ Loop Template

```java
while (right < n) {
    add nums[right] to window

    while (window is invalid) {
        remove nums[left] from window
        left++
    }

    update answer
    right++
}
```

If you **memorize this**, 80% of sliding window problems are solved.

---

## 5ï¸âƒ£ Fixed Size Sliding Window â€“ Deep Dive

### ğŸ”¹ Problem Type

> Find something **best / worst** among all subarrays of size `k`

### ğŸ§  Thinking Steps

1. Build first window of size `k`
2. Slide:

   * Remove left element
   * Add right element
3. Update answer

---

### ğŸŸ¢ MEDIUM #1

**Maximum Sum Subarray of Size K**

**Problem**

> Given an array of integers, find the maximum sum of any contiguous subarray of size `k`.

#### Brute Force

* O(nÂ·k)

#### Sliding Window

* O(n)

```java
int maxSum = 0, windowSum = 0;
int left = 0;

for (int right = 0; right < nums.length; right++) {
    windowSum += nums[right];

    if (right >= k - 1) {
        maxSum = Math.max(maxSum, windowSum);
        windowSum -= nums[left];
        left++;
    }
}
```

---

### ğŸŸ¢ MEDIUM #2

**Average of Subarrays of Size K**

Same logic â†’ return averages instead of max.

---

### ğŸ”´ HARD #1

**Maximum Average Subarray II (LeetCode 644)**
(Binary search + sliding window)
ğŸ‘‰ Important for Google (hybrid pattern).

---

## 6ï¸âƒ£ Variable Size Sliding Window â€“ Deep Dive (MOST ASKED)

### ğŸ”¹ Problem Type

> Longest / shortest subarray satisfying a condition

### ğŸ§  Thinking Steps

1. Expand window (`right`)
2. Check validity
3. If invalid â†’ shrink (`left`)
4. Update answer

---

### ğŸŸ¢ MEDIUM #3

**Longest Substring Without Repeating Characters**

```java
Map<Character, Integer> map = new HashMap<>();
int left = 0, maxLen = 0;

for (int right = 0; right < s.length(); right++) {
    char c = s.charAt(right);

    if (map.containsKey(c)) {
        left = Math.max(left, map.get(c) + 1);
    }

    map.put(c, right);
    maxLen = Math.max(maxLen, right - left + 1);
}
```

ğŸ“Œ **Key Insight**

* Move `left` only forward
* Never reset window

---

### ğŸŸ¢ MEDIUM #4

**Minimum Size Subarray Sum â‰¥ K**

```java
int left = 0, sum = 0, minLen = Integer.MAX_VALUE;

for (int right = 0; right < nums.length; right++) {
    sum += nums[right];

    while (sum >= k) {
        minLen = Math.min(minLen, right - left + 1);
        sum -= nums[left];
        left++;
    }
}
```

---

### ğŸ”´ HARD #2

**Longest Substring with At Most K Distinct Characters**

```java
Map<Character, Integer> freq = new HashMap<>();
int left = 0, maxLen = 0;

for (int right = 0; right < s.length(); right++) {
    freq.put(s.charAt(right), freq.getOrDefault(s.charAt(right), 0) + 1);

    while (freq.size() > k) {
        char l = s.charAt(left);
        freq.put(l, freq.get(l) - 1);
        if (freq.get(l) == 0) freq.remove(l);
        left++;
    }

    maxLen = Math.max(maxLen, right - left + 1);
}
```

---

## 7ï¸âƒ£ Sliding Window + Frequency (Anagram Type)

### ğŸŸ¢ MEDIUM #5

**Find All Anagrams in a String**

Key idea:

* Fixed window
* Compare frequency maps

---

### ğŸ”´ HARD #3

**Minimum Window Substring (VERY IMPORTANT)**

This is the **ultimate sliding window problem**.

> â€œSmallest window in `s` that contains all chars of `t`â€

Appears in:

* Google
* Amazon
* Microsoft

(Weâ€™ll do a **separate deep session** on this alone.)

---

## 8ï¸âƒ£ When NOT to Use Sliding Window âŒ

* Subsequence (not contiguous)
* Multiple rearrangements allowed
* Non-contiguous selection
  â†’ Use **DP / Greedy / Backtracking**

---

## 9ï¸âƒ£ Interview Cheat Sheet (MEMORIZE)

| Keyword              | Pattern          |
| -------------------- | ---------------- |
| subarray / substring | Sliding Window   |
| size k               | Fixed window     |
| longest / shortest   | Variable window  |
| unique / distinct    | HashMap window   |
| at most / at least   | Shrink condition |

---

## 10ï¸âƒ£ Your Practice Set (MANDATORY)

### âœ… Medium (Solve First)

1. Maximum Sum Subarray of Size K
2. Longest Substring Without Repeating Characters
3. Minimum Size Subarray Sum
4. Longest Repeating Character Replacement

### ğŸ”¥ Hard (After Mastery)

1. Minimum Window Substring
2. Subarrays with K Different Integers
3. Longest Substring with At Most K Distinct Characters

---

## ğŸš€ Next Steps

If you want, next we can:

* **Pattern #2: Two Pointers**
* OR solve **Minimum Window Substring** line-by-line
* OR build a **30-day FAANG DSA plan**

Just tell me ğŸ‘
